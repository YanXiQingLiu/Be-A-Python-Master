1.1 解压序列赋值给多个变量
问题：现在有一个包含 N 个元素的元组或者是序列，怎样将它里面的值解压后同时赋值给 N 个变量？
解决方案：任何的序列(或者是可迭代对象)可以通过一个简单的赋值语句解压并赋值给多个变量。 唯一的前提就是变量的数量必须跟序列元素的数量是一样的。

1.2 解压可迭代对象赋值给多个变量
问题：如果一个可迭代对象的元素个数超过变量个数时，会抛出一个 ValueError 。 那么怎样才能从这个可迭代对象中解压出 N 个元素出来？
解决方案： Python 的星号表达式可以用来解决这个问题。比如，你在学习一门课程，在学期末的时候， 你想统计下家庭作业的平均成绩，
但是排除掉第一个和最后一个分数。如果只有四个分数，你可能就直接去简单的手动赋值， 但如果有24个呢？这时候星号表达式就派上用场了。

1.3 保留最后 N 个元素
问题：在迭代操作或者其他操作的时候，怎样只保留最后有限几个元素的历史记录？
解决方案：保留有限历史记录正是 collections.deque 大显身手的时候。比如，下面的代码在多行上面做简单的文本匹配， 并只返回在前 N 行中匹配成功的行。

1.4 查找最大或最小的 N 个元素
问题：怎样从一个集合中获得最大或者最小的N个元素列表？
解决方案： heapq 模块有两个函数： nlargest() 和 nsmallest() 可以完美解决这个问题。

1.5 实现一个优先级队列
问题：怎样实现一个按优先级排序的队列？ 并且在这个队列上面每次 pop 操作总是返回优先级最高的那个元素。
解决方案：下面的类利用 heapq 模块实现了一个简单的优先级队列。

1.6 字典中的键映射多个值
问题：怎样实现一个键对应多个值的字典(也叫 multidict )？
解决方案：一个字典就是一个键对应一个单值的映射。如果你想要一个键映射多个值，那么你就需要将这多个值放到另外的容器中， 比如列表或者集合里面。
比如，你可以像下面这样构造这样的字典。
    #d = {'a' : [1, 2, 3],'b' : [4, 5]}
    #e = {'a' : {1, 2, 3},'b' : {4, 5}}
    
1.7 字典排序
问题：你想创建一个字典，并且在迭代或序列化这个字典的时候能够控制元素的顺序。
解决方案：为了能控制一个字典中元素的顺序，你可以使用 collections 模块中的 OrderedDict 类。在迭代操作的时候它会保持元素被插入时的顺序，示例请见C07。

1.8 字典的运算
问题：怎样在数据字典中执行一些计算操作(比如求最小值、最大值、排序等等)？
解决方案：考虑下面的股票名和价格映射字典。

1.9 查找两字典的相同点
问题：怎样在两个字典中寻寻找相同点(比如相同的键、相同的值等等)？
解决方案：考虑下面两个字典：
    a = {'x' : 1,'y' : 2,'z' : 3}
    b = {'w' : 10,'x' : 11,'y' : 2}

1.10 删除序列相同元素并保持顺序
问题：怎样在一个序列上面保持元素顺序的同时消除重复的值？
解决方案：如果序列上的值都是 hashable 类型，那么可以很简单的利用集合或者生成器来解决这个问题。

1.11 命名切片
问题：你的程序已经出现一大堆已无法直视的硬编码切片下标，然后你想清理下代码。
解决方案：假定你有一段代码要从一个记录字符串中几个固定位置提取出特定的数据字段(比如文件或类似格式)。

1.12 序列中出现次数最多的元素
问题：怎样找出一个序列中出现次数最多的元素呢？
解决方案：collections.Counter 类就是专门为这类问题而设计的， 它甚至有一个有用的 most_common() 方法直接给了你答案。
为了演示，先假设你有一个单词列表并且想找出哪个单词出现频率最高。

1.13 通过某个关键字排序一个字典列表
问题：你有一个字典列表，你想根据某个或某几个字典字段来排序这个列表。
解决方案：通过使用 operator 模块的 itemgetter 函数，可以非常容易的排序这样的数据结构。 假设你从数据库中检索出来网站会员信息列表，并且以下列的数据结构返回：
    rows = [
    {'fname': 'Brian', 'lname': 'Jones', 'uid': 1003},
    {'fname': 'David', 'lname': 'Beazley', 'uid': 1002},
    {'fname': 'John', 'lname': 'Cleese', 'uid': 1001},
    {'fname': 'Big', 'lname': 'Jones', 'uid': 1004}
    ]

1.14 排序不支持原生比较的对象
问题：你想排序类型相同的对象，但是他们不支持原生的比较操作。
解决方案：内置的 sorted() 函数有一个关键字参数 key ，可以传入一个 callable 对象给它， 这个 callable 对象对每个传入的对象返回一个值，
这个值会被 sorted 用来排序这些对象。比如，如果你在应用程序里面有一个 User 实例序列，并且你希望通过他们的 user_id 属性进行排序， 
你可以提供一个以 User 实例作为输入并输出对应 user_id 值的 callable对象。

1.15 通过某个字段将记录分组
问题：你有一个字典或者实例的序列，然后你想根据某个特定的字段比如 date 来分组迭代访问。
解决方案： itertools.groupby()  函数对于这样的数据分组操作非常实用。 为了演示，假设你已经有了下列的字典列表。

1.16 过滤序列元素
问题：你有一个数据序列，想利用一些规则从中提取出需要的值或者是缩短序列。
解决方案：最简单的过滤序列元素的方法就是使用列表推导。

1.17 从字典中提取子集
问题：你想构造一个字典，它是另外一个字典的子集。
解决方案：最简单的方式是使用字典推导。
    prices = {'ACME': 45.23,'AAPL': 612.78,'IBM': 205.55,'HPQ': 37.20,'FB': 10.75}
    # Make a dictionary of all prices over 200
    p1 = {key: value for key, value in prices.items() if value > 200}
    # Make a dictionary of tech stocks
    tech_names = {'AAPL', 'IBM', 'HPQ', 'MSFT'}
    p2 = {key: value for key, value in prices.items() if key in tech_names}

1.18 映射名称到序列元素
问题：你有一段通过下标访问列表或者元组中元素的代码，但是这样有时候会使得你的代码难以阅读， 于是你想通过名称来访问元素。
解决方案： collections.namedtuple() 函数通过使用一个普通的元组对象来帮你解决这个问题。 这个函数实际上是一个返回 Python 中标准元组类型子类的
    一个工厂方法。 你需要传递一个类型名和你需要的字段给它，然后它就会返回一个类，你可以初始化这个类，为你定义的字段传递值等。

1.19 转换并同时计算数据
问题：
你需要在数据序列上执行聚集函数(比如 sum() , min() , max() )， 但是首先你需要先转换或者过滤数据。
解决方案：
一个非常优雅的方式去结合数据计算与转换就是使用一个生成器表达式参数。 比如，如果你想计算平方和，可以像下面这样做：
    nums = [1, 2, 3, 4, 5]
    s = sum(x * x for x in nums)

1.20 合并多个字典或映射
问题：现在有多个字典或者映射，你想将它们从逻辑上合并为一个单一的映射后执行某些操作，比如查找值或者检查某些键是否存在。
解决方案：加入你有如下两个字典:
        a = {'x': 1, 'z': 3 }
    b = {'y': 2, 'z': 4 }
    现在假设你必须在两个字典中执行查找操作(比如先从 a 中找，如果找不到再在 b 中
    找)。 一个非常简单扼解决方案就是使用 collections 模块中的 ChainMap 类。比如：
        from collections import ChainMap
        c = ChainMap(a,b)
        print(c['x']) # Outputs 1 (from a)
        print(c['y']) # Outputs 2 (from b)
        print(c['z']) # Outputs 3 (from a)









